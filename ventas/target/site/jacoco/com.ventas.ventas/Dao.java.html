<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Dao.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ventas</a> &gt; <a href="index.source.html" class="el_package">com.ventas.ventas</a> &gt; <span class="el_source">Dao.java</span></div><h1>Dao.java</h1><pre class="source lang-java linenums">package com.ventas.ventas;

import java.io.IOException;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.Query;
import org.springframework.http.ResponseEntity;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import javassist.tools.framedump;

import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;

/**
 * &lt;p&gt;Clase utilizada para crear los servicios que interactuan con la base de datos de oracle &lt;/p&gt;
 */
@Repository
public class Dao {
    /**
        *&lt;p&gt;Constructor de la clase dao &lt;/p&gt; 
    */
<span class="nc" id="L35">    public Dao(){</span>

<span class="nc" id="L37">    }</span>

    /**
        *&lt;p&gt;Inicializar el jdbcTemplate para generar las consultas &lt;/p&gt; 
    */
    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
        *&lt;p&gt;Constructor para inicializar los servicios de jdbc &lt;/p&gt; 
    */
<span class="nc" id="L48">    public Dao(JdbcTemplate jdbcTemplate) {</span>
<span class="nc" id="L49">        this.jdbcTemplate = jdbcTemplate;</span>
<span class="nc" id="L50">    }</span>


    //TODO: Método para el manejo de catalogo de terminales 

    /**
     * &lt;p&gt;Método para listar todas las terminales en la pagina de inicio &lt;/p&gt;
          * @return listaDis la lista con todos las terminales disponibles  
    */
    public List&lt;Telefono&gt; list() {
<span class="nc" id="L60">        String sql = &quot;select *from VENTAS.BODEGA inner join VENTAS.FABRICA on origen = id_FABRICA  where id_estados = 3 or id_estados = 4&quot;;</span>
<span class="nc" id="L61">        List&lt;Telefono&gt; listaDis = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L62">        return listaDis;</span>

    }

     /**
     * &lt;p&gt;Método para listar las caracterizticas de solo una terminal&lt;/p&gt;
     * @param id es la llave primaria de cada terminal
     * @return listaIn es una lista con las caracterizticas del telefono con el id que se manda como parametro 
    */
    public List&lt;Telefono&gt; list2(int id) {
<span class="nc" id="L72">        String sql = &quot;select *from VENTAS.BODEGA inner join VENTAS.FABRICA on origen = id_FABRICA where id_BODEGA  = ?&quot;;</span>
<span class="nc" id="L73">        Object[] args = { id };</span>
<span class="nc" id="L74">        List&lt;Telefono&gt; listaIn = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L75">        return listaIn;</span>

    }

    /**
     * &lt;p&gt;Método para obtener una terminal a manera de objeto &lt;/p&gt;
     * @param id es la llave primaria de cada terminal
     * @return nuevo objeto de tipo telefono 
    */    
    public Telefono get(int id) {
<span class="nc" id="L85">        String sql = &quot;SELECT * FROM VENTAS.BODEGA where id_BODEGA = ?&quot;;</span>
<span class="nc" id="L86">        Object[] args = { id };</span>
<span class="nc" id="L87">        Telefono nuevo = jdbcTemplate.queryForObject(sql, args, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L88">        return nuevo;</span>
    }

     /**
     * &lt;p&gt;Método para actualizar las fotos de las terminales &lt;/p&gt;
     * @deprecated
     * Este Método quedo desactualizado, se paso a manejar las imagenes con url 
     * @param foto son los bytes de la foto
     * @param consulta el string para generar la consulta para actualizar los dispositivos
     * @param id la llave primaria para ejectuar la consulta sobre un registro en particular
    */
    public void updateF(byte[] foto, String consulta, int id) {

<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (foto.length &gt; 0) {</span>
<span class="nc" id="L102">            jdbcTemplate.update(consulta, foto, id);</span>

        }

<span class="nc" id="L106">    }</span>

    /**
     * &lt;p&gt;Método para actualizar los parametros de las terminales &lt;/p&gt;
     * @param nuevo objeto de tipo de telefono 
     * &lt;p&gt;Se utiliza el objeto completo para actualizar todos los campos&lt;/p&gt;
     * &lt;b&gt;Es importante usar  '=:' para actualizar los campos y no dejar espacios&lt;/b&gt;
    */  
    public void updateT(Telefono nuevo) {
<span class="nc" id="L115">        String sql = &quot;UPDATE VENTAS.BODEGA SET existencia=:existencia , precio_lista=:precio_lista, codigo_modelo=:codigo_modelo, ram=:ram, almacenamiento=:almacenamiento, procesador=:procesador, numero_cores=:numero_cores,color=:color,descripcion=:descripcion,nombret=:nombret,origen=origen,foto1=:foto1,foto2=:foto2,foto3=:foto3 WHERE id_BODEGA=:id_BODEGA&quot;;</span>
<span class="nc" id="L116">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(nuevo);</span>

<span class="nc" id="L118">        NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(jdbcTemplate);</span>
<span class="nc" id="L119">        template.update(sql, param);        </span>

<span class="nc" id="L121">    }</span>

     /**
     * &lt;p&gt;Método para crear nuevas terminales&lt;/p&gt;
     * @param nuevo objeto de tipo de telefono, que es la terminal a guardar  
     * @throws IOException
     * &lt;p&gt; Los insert a la base de datos son manejados por el jdbctemplate que ejecuta la consulta&lt;/p&gt;
      */ 
    public void save(Telefono nuevo) throws IOException { 

<span class="nc" id="L131">        SimpleJdbcInsert insertActor = new SimpleJdbcInsert(jdbcTemplate);</span>
<span class="nc" id="L132">        insertActor.withSchemaName(&quot;VENTAS&quot;).withTableName(&quot;BODEGA&quot;).usingColumns( &quot;existencia&quot;,</span>
                &quot;precio_lista&quot;, &quot;codigo_modelo&quot;, &quot;ram&quot;, &quot;almacenamiento&quot;, &quot;procesador&quot;, &quot;numero_cores&quot;, &quot;color&quot;,
                &quot;descripcion&quot;, &quot;nombret&quot;,&quot;origen&quot;,&quot;id_estados&quot;,&quot;foto1&quot;,&quot;foto2&quot;,&quot;foto3&quot;);
<span class="nc" id="L135">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(nuevo);</span>

<span class="nc" id="L137">        insertActor.execute(param);    </span>
<span class="nc" id="L138">    }</span>

    /**
     * &lt;p&gt;Método ara salvar los numeros de serie&lt;/p&gt;
     * @param consulta  objeto de tipo de telefono, que es la terminal a guardar  
     * &lt;p&gt; Los insert a la base de datos son manejados por el jdbctemplate que ejecuta la consulta&lt;/p&gt;
      */ 
      public void saveNum(String num,String modelo,int id) {
<span class="nc" id="L146">        String sql = &quot;insert into ventas.numeros_serie(num_series,modelo,id_BODEGA) values(?,?,?) &quot;;</span>
<span class="nc" id="L147">        jdbcTemplate.update(sql, num,modelo,id);</span>

 
       
   

        

<span class="nc" id="L155">    }</span>

        /**
     * &lt;p&gt;Obtner el id de la BODEGA&lt;/p&gt; 
     * &lt;p&gt; Los insert a la base de datos son manejados por el jdbctemplate que ejecuta la consulta&lt;/p&gt;
      */
      public Telefono getlastID() {
<span class="nc" id="L162">        String sql = &quot;select *from ventas.BODEGA order by id_BODEGA desc FETCH FIRST 1 ROWS ONLY &quot;;</span>
<span class="nc" id="L163">        Telefono registro = jdbcTemplate.queryForObject(sql, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L164">        return registro;</span>
    } 
      







     /**
     * &lt;p&gt;Método para eliminar terminales&lt;/p&gt;
     * @param id el identificador para eliminar especificamente una terminal   
     * &lt;p&gt;A través del jdbcTemplate ejecutamos un update que ejecuta el delete&lt;/p&gt;     
    */ 
    public void delete(int id) {
<span class="nc" id="L180">        String sql = &quot;DELETE FROM VENTAS.BODEGA WHERE id_BODEGA = ?&quot;;</span>
<span class="nc" id="L181">        jdbcTemplate.update(sql, id);</span>
<span class="nc" id="L182">    }</span>

    /**
     * &lt;p&gt;Método para retornar una lista con opciones del tipo de telefono, usado principalemente en el combobox de marcas&lt;/p&gt;
     * @param query es la consulta que generamos para traer las opciones  
     * @return listaOpciones una lista con las marcas de telefonos 
     * &lt;p&gt;Este método puede devolver una lista de cualquier cosa que este definida dentro de la clase telefono&lt;/p&gt;
     */ 
    public List&lt;Telefono&gt; listOpciones(String query) {
<span class="nc" id="L191">        String sql = query;</span>

<span class="nc" id="L193">        List&lt;Telefono&gt; listaOpciones = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L194">        return listaOpciones;</span>

    }


  


    /**
     * &lt;p&gt;Método para realizar una busqueda de terminales&lt;/p&gt;
     * @param buscar la cadena de texto que recibe para hacer la busqueda   
     * @return listaBusqueda es una lista de tipo telefono que retorna todos las terminales que cumplan con el criterio de busqueda
     
    */ 
    public List&lt;Telefono&gt; listBus(String buscar) {
<span class="nc" id="L209">        String sql = &quot;select *from VENTAS.BODEGA where nombret like ?   &quot;;</span>
<span class="nc" id="L210">        Object[] args = { buscar };</span>
<span class="nc" id="L211">        List&lt;Telefono&gt; listaBusqueda = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L212">        return listaBusqueda;</span>

    }

     /**
     * &lt;p&gt;Método para borrar terminal de la BODEGA&lt;/p&gt;
     * @param id identificador de la terminal a eliminar
     
     
    */ 
    public void deleteT(int id) {
<span class="nc" id="L223">        String sql = &quot;DELETE FROM VENTAS.BODEGA WHERE id_BODEGA = ?&quot;;</span>
<span class="nc" id="L224">        jdbcTemplate.update(sql, id);</span>
<span class="nc" id="L225">    }</span>

    /**
     * &lt;p&gt;Método para mostrar dispositivos de BODEGA&lt;/p&gt;
     * @return terminalList la lista de tipo telefono con todas las terminales de BODEGA
     
     
    */ 
    public List&lt;Telefono&gt; bodega() {
<span class="nc" id="L234">        String sql = &quot;select *from ventas.BODEGA&quot;;</span>
<span class="nc" id="L235">        List&lt;Telefono&gt;    terminalList = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L236">        return   terminalList;</span>

    }



    //TODO: Métodos para el manejo del cátalgo de clientes 

  /**
     * &lt;p&gt;Método para listar todos los clientes dentro de la base de datos, quitando el registro de cliente individual&lt;/p&gt;
     * @return listCli lista del tipo Cliente. 
     
    */ 
    public List&lt;Cliente&gt; listaCliente() {
<span class="nc" id="L250">        String sql = &quot;select * from ventas.clientes where id_cliente != '1' and id_cliente  != 2&quot;;</span>
<span class="nc" id="L251">        List&lt;Cliente&gt; listCli = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Cliente.class));</span>
<span class="nc" id="L252">        return listCli;</span>
    }

     /**
     * &lt;p&gt;Método para retornar una lista con opciones del tipo de cliente, usado principalemente para traer los tipos de clientes&lt;/p&gt;
     * @param query es la consulta que generamos para traer las opciones  
     * @return una lista de opcioens para el tipo de cliente
     * &lt;p&gt;Este método puede devolver una lista de cualquier cosa que este definida dentro de la clase cliente&lt;/p&gt;
     
    */ 
    public List&lt;Cliente&gt; listOpcionesC(String query) {
<span class="nc" id="L263">        String sql = query;</span>

<span class="nc" id="L265">        List&lt;Cliente&gt; listaOpcionesC = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Cliente.class));</span>
<span class="nc" id="L266">        return listaOpcionesC;</span>

    }

     /**
     * &lt;p&gt;Método salvar info de un cliente dentro de la bd&lt;/p&gt;
     * @param ci objeto de tipo cliente, es el que se guarda dentro de la bd   
     
     
    */     
    public void saveCliente(Cliente ci) {
<span class="nc" id="L277">        SimpleJdbcInsert insertActor = new SimpleJdbcInsert(jdbcTemplate);</span>
<span class="nc" id="L278">        insertActor.withSchemaName(&quot;VENTAS&quot;).withTableName(&quot;CLIENTES&quot;).usingColumns(&quot;nombre&quot;, &quot;apellido&quot;,&quot;nit&quot;, &quot;correo&quot;,  &quot;inicio_suscripcion&quot;, &quot;vencimiento_suscripcion&quot;,&quot;id_tipo_cliente&quot;,&quot;patente_comercio&quot;);</span>
<span class="nc" id="L279">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(ci);</span>
<span class="nc" id="L280">        insertActor.execute(param);</span>
<span class="nc" id="L281">    }</span>


    /**
     * &lt;p&gt;Método para eliminar el cliente con el id&lt;/p&gt;
     * @param id identificador del cliente a borrar 

     
    */    
    public void deletecliente(int id) {
<span class="nc" id="L291">        String sql = &quot;DELETE FROM VENTAS.CLIENTES WHERE id_cliente = ?&quot;;</span>
<span class="nc" id="L292">        jdbcTemplate.update(sql, id);</span>
<span class="nc" id="L293">    }</span>

    /**
     * &lt;p&gt;Método para actualizar la info del cliente dentro de la bd&lt;/p&gt;
     * @param ci identificador del cliente a actualizar    
     
    */ 
    public void updateC(Cliente ci) {
<span class="nc" id="L301">        String sql = &quot;UPDATE VENTAS.CLIENTES SET  nombre=:nombre, apellido=:apellido,nit=:nit,correo=:correo, inicio_suscripcion=:inicio_suscripcion, vencimiento_suscripcion=:vencimiento_suscripcion,patente_comercio=:patente_comercio ,id_tipo_cliente=:id_tipo_cliente WHERE id_cliente=:id_cliente&quot;;</span>
<span class="nc" id="L302">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(ci);</span>

<span class="nc" id="L304">        NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(jdbcTemplate);</span>
<span class="nc" id="L305">        template.update(sql, param);</span>
<span class="nc" id="L306">    }</span>

    /**
     * &lt;p&gt;Método para obtener el objeto de un cliente en particular&lt;/p&gt;
     * @param id identificador del cliente a consultar 
     * @return ci el objeto cliente del respectivo id
     
    */ 
    public Cliente getC(int id) {
<span class="nc" id="L315">        String sql = &quot;SELECT * FROM VENTAS.CLIENTES WHERE id_cliente = ?&quot;;</span>
<span class="nc" id="L316">        Object[] args = { id };</span>
<span class="nc" id="L317">        Cliente ci = jdbcTemplate.queryForObject(sql, args, BeanPropertyRowMapper.newInstance(Cliente.class));</span>
<span class="nc" id="L318">        return ci;</span>

    }

    /**
     * &lt;p&gt;Método para obtener una lista con la info del cliente individual/&lt;p&gt;
     * @param id identificador del cliente a consultar 
     *  @return una lista de tipo cliente con la info del cliente especifico     
     
    */ 
    public List&lt;Cliente&gt; listaCliente2(int id) {
<span class="nc" id="L329">        String sql = &quot;select * from ventas.clientes where id_cliente = ?&quot;;</span>
<span class="nc" id="L330">        Object[] args = { id };</span>
<span class="nc" id="L331">        List&lt;Cliente&gt; listasC = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Cliente.class));</span>
<span class="nc" id="L332">        return listasC;</span>

    }
    
    
    
    //TODO:Manejo de las marcas
    /**
     * @deprecated
     * &lt;p&gt;Las marcas pasamos a manejarlas con las FABRICAs&lt;/p&gt;
     * @return una lista con las marcas
     
    */ 
    public List&lt;Marca&gt; listMarca() {
<span class="nc" id="L346">        String sql = &quot;select * from VENTAS.marca_dispositivo&quot;;</span>
<span class="nc" id="L347">        List&lt;Marca&gt; listMar = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Marca.class));</span>
<span class="nc" id="L348">        return listMar;</span>
    }

    /**
     * @deprecated
     * @param id unid especifoc de la marca
     * @return lista con las marcas
     * &lt;p&gt;Las marcas pasamos a manejarlas con las FABRICAs&lt;/p&gt;
     
    */ 
    public List&lt;Marca&gt; listMar2(int id) {
<span class="nc" id="L359">        String sql = &quot;select * from VENTAS.marca_dispositivo where id_marca = ?&quot;;</span>
<span class="nc" id="L360">        Object[] args = { id };</span>
<span class="nc" id="L361">        List&lt;Marca&gt; listMar = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Marca.class));</span>
<span class="nc" id="L362">        return listMar;</span>

    }
    /**
     * @deprecated
     * &lt;p&gt;Las marcas pasamos a manejarlas con las FABRICAs&lt;/p&gt;
    */ 
    public void saveMarca(Marca ma) {
<span class="nc" id="L370">        SimpleJdbcInsert insertActor = new SimpleJdbcInsert(jdbcTemplate);</span>
<span class="nc" id="L371">        insertActor.withSchemaName(&quot;VENTAS&quot;).withTableName(&quot;MARCA_DISPOSITIVO&quot;).usingColumns(&quot;nombre_marca&quot;);</span>
<span class="nc" id="L372">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(ma);</span>

<span class="nc" id="L374">        insertActor.execute(param);</span>
<span class="nc" id="L375">    }</span>
    /**
     * @deprecated
     * &lt;p&gt;Las marcas pasamos a manejarlas con las FABRICAs&lt;/p&gt;
     
    */ 
    public void deleteMarca(int id) {
<span class="nc" id="L382">        String sql = &quot;DELETE FROM VENTAS.marca_dispositivo WHERE id_marca = ?&quot;;</span>
<span class="nc" id="L383">        jdbcTemplate.update(sql, id);</span>
<span class="nc" id="L384">    }</span>
    /**
     * @deprecated
     * &lt;p&gt;Las marcas pasamos a manejarlas con las FABRICAs&lt;/p&gt;
     
    */ 
    public void updateMarca(Marca ma) {
<span class="nc" id="L391">        String sql = &quot;UPDATE VENTAS.marca_dispositivo SET  nombre_marca=:nombre_marca WHERE id_marca=:id_marca&quot;;</span>
<span class="nc" id="L392">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(ma);</span>

<span class="nc" id="L394">        NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(jdbcTemplate);</span>

<span class="nc" id="L396">        template.update(sql, param);</span>

<span class="nc" id="L398">    }</span>


    //TODO: Métodos para el manejo de pedidos 

    /**
         * &lt;p&gt;Método para insertar un pedido realizado por algun cliente &lt;/p&gt;
         * @param nuevo es el objeto de tipo Pedido con la info a guardar 
         * @throws IOException

         
    */ 
    public void insertarPedido(Pedido nuevo) throws IOException { 
<span class="nc" id="L411">        SimpleJdbcInsert insertActor = new SimpleJdbcInsert(jdbcTemplate);</span>
<span class="nc" id="L412">        insertActor.withSchemaName(&quot;VENTAS&quot;).withTableName(&quot;PEDIDO&quot;).usingColumns( &quot;ID_CLIENTE&quot;,&quot;CANTIDADP&quot;, &quot;CANTIDADP_A&quot;,&quot;ID_BODEGA&quot;,&quot;TOTAL_C&quot;);</span>
<span class="nc" id="L413">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(nuevo);</span>
<span class="nc" id="L414">        insertActor.execute(param);    </span>
<span class="nc" id="L415">    }</span>

    /**
         * @deprecated
         * ya no se uso para obtener el id de un cliente en especifico 
         * &lt;p&gt;Obtener info de un cliente en particular &lt;/p&gt;
         *@param nit se pasa para obtener la info de un cliente en especifico 
         
    */ 
    public List&lt;Cliente&gt; idCliente(int nit) {
<span class="nc" id="L425">        String sql = &quot;select id_cliente from ventas.clientes where nit = ?&quot;;</span>
<span class="nc" id="L426">        Object[] args = { nit };</span>
<span class="nc" id="L427">        List&lt;Cliente&gt; idC = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Cliente.class));</span>
<span class="nc" id="L428">        return idC;</span>
    }


    /**
         * &lt;p&gt;Obtener info de un cliente  &lt;/p&gt;
         *@param nit para obtener info de un cliente en particular 
         
    */ 
    public List&lt;Cliente&gt; clienteNit(int nit) {
<span class="nc" id="L438">        String sql = &quot;select * from ventas.clientes where nit = ?&quot;;</span>
<span class="nc" id="L439">        Object[] args = { nit };</span>
<span class="nc" id="L440">        List&lt;Cliente&gt; idCn = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Cliente.class));</span>
<span class="nc" id="L441">        return idCn;</span>

    }

     /**
         * &lt;p&gt;Confirmar las terminales pedidas por un cliente  &lt;/p&gt;
         *@param id el identificador de la persona que realiza el pedido 
         @param cred si el pedido se realizara al credito 
         
    */    
    public void facturar(int id,int cred) {
<span class="nc" id="L452">        String sql = &quot;UPDATE VENTAS.pedido SET credito = ? where id_cliente = ? and compra != 1  &quot;;</span>
<span class="nc" id="L453">        jdbcTemplate.update(sql,cred,id);</span>

<span class="nc" id="L455">    }</span>

    /**
         * &lt;p&gt;Mostrar las terminales añadidas a un pedido  &lt;/p&gt;
         *@param id el identificador del cliente al que pertence el carro 
         
    */ 
    public List&lt;Pedido&gt; mostrarCarro(int id) {
        

<span class="nc" id="L465">        String sql = &quot;select *from ventas.BODEGA inner join ventas.pedido using(id_BODEGA) where id_cliente = ? and compra != 1&quot;;</span>
<span class="nc" id="L466">        Object[] args = { id };</span>
<span class="nc" id="L467">        List&lt;Pedido&gt; listaC = jdbcTemplate.query(sql,args, BeanPropertyRowMapper.newInstance(Pedido.class));</span>
<span class="nc" id="L468">        return listaC;</span>

    }


    /**
         * &lt;p&gt;Mostrar la factura del pedido que se esta realizando   &lt;/p&gt;
         *@param id identificador del cliente a mostrar factura 
         
    */ 
    public List&lt;Pedido&gt; mostrarFactura(int id) {
        

<span class="nc" id="L481">        String sql = &quot;select (ventas.precio(id_tipo_cliente,id_BODEGA)*(cantidadp+cantidadp_a)) as precio_total, b.* from(  select  *from ventas.clientes inner join(    select *from ventas.BODEGA inner join ventas.pedido using(id_BODEGA) )a  using(id_cliente))b where id_cliente = ? and compra =0 &quot;;</span>
<span class="nc" id="L482">        Object[] args = { id };</span>
<span class="nc" id="L483">        List&lt;Pedido&gt; listaF = jdbcTemplate.query(sql,args,  BeanPropertyRowMapper.newInstance(Pedido.class));</span>
<span class="nc" id="L484">        return listaF;</span>

    }
   
    /**
         * &lt;p&gt;Mostrar el total de la compra   &lt;/p&gt;
         *@param id total de la compra de un cliente en especifico
         
    */ 
    public List&lt;Pedido&gt; total(int id) {
        

<span class="nc" id="L496">        String sql = &quot;select sum(total) as totales  from(select (ventas.precio(id_tipo_cliente,id_BODEGA)*(cantidadp+cantidadp_a)) as total, b.* from(select  *from ventas.clientes inner join( select *from ventas.BODEGA inner join ventas.pedido using(id_BODEGA) )a  using(id_cliente))b)c where id_cliente = ? and compra = 0 &quot;;</span>
<span class="nc" id="L497">        Object[] args = { id };</span>
<span class="nc" id="L498">        List&lt;Pedido&gt; listaT = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Pedido.class));</span>
<span class="nc" id="L499">        return listaT;</span>

    }


    /**
         * &lt;p&gt;Mostrar el total de la compra una vez confirmada  &lt;/p&gt;
         *@param id total de la compra de un cliente en especifico
         
    */ 
    public List&lt;Pedido&gt; total2(int id) {
        

<span class="nc" id="L512">        String sql = &quot;select sum(total) as totales  from(select (ventas.precio(id_tipo_cliente,id_BODEGA)*(cantidadp+cantidadp_a)) as total, b.* from(select  *from ventas.clientes inner join( select *from ventas.BODEGA inner join ventas.pedido using(id_BODEGA) )a  using(id_cliente))b)c where id_cliente = ? and compra = 1 &quot;;</span>
<span class="nc" id="L513">        Object[] args = { id };</span>
<span class="nc" id="L514">        List&lt;Pedido&gt; listaT = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Pedido.class));</span>
<span class="nc" id="L515">        return listaT;</span>

    }
    
    /**
         * &lt;p&gt;Eliminar un pedido añadido al carro  &lt;/p&gt;
         *@param id identificador del pedido a eliminar 
         
    */
    public void deletePedido(int id) {
<span class="nc" id="L525">        String sql = &quot;DELETE FROM VENTAS.pedido where id_pedido = ?&quot;;</span>
<span class="nc" id="L526">        jdbcTemplate.update(sql, id);</span>
<span class="nc" id="L527">    }</span>

    /**
         * &lt;p&gt;Confirmar las compras &lt;/p&gt;
         *@param id identificador del cliente que realiza la compra 
         *Este metodo es importante porque es el que le indica al trigger que entre en funcionamiento 
         
    */
    public void comprarT(int id) {
<span class="nc" id="L536">        String sql = &quot;update ventas.pedido set id_estado = 2 , compra = 1 where id_cliente = ? and compra = 0&quot;;</span>
<span class="nc" id="L537">        jdbcTemplate.update(sql, id);</span>

<span class="nc" id="L539">        String sql2 = &quot;update ventas.pedido set descontado = 1 where id_cliente = ?&quot;;</span>
<span class="nc" id="L540">        jdbcTemplate.update(sql2, id);</span>

<span class="nc" id="L542">    }</span>








   
    //TODO: Manejo de usuarios 
  
    /**
         * &lt;p&gt;Método para obtener info de un usuario &lt;/p&gt;
         * @param usuario el usuario que ingresa 
         * @param contraseña la contraseña que ingresa 
         
    */ 
    public List&lt;Usuarios&gt; listUsuarios( String usuario,String contraseña) {
        

<span class="nc" id="L563">        String sql = &quot;select *from VENTAS.USUARIO where usuario = ? and contraseña = ?&quot;;</span>
<span class="nc" id="L564">        Object[] args = { usuario,contraseña };</span>
<span class="nc" id="L565">        List&lt;Usuarios&gt; listaU = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Usuarios.class));</span>
<span class="nc" id="L566">        return listaU;</span>

    }

    /**
         * &lt;p&gt;Método mostrar a todos los usuarios dentro de la base de datos &lt;/p&gt;
         *@return listaU una lista de tipo Usuarios con todos los usuarios y su info
         
    */ 
    public List&lt;Usuarios&gt; usuariosMostrar() {
        

<span class="nc" id="L578">        String sql = &quot;select *from VENTAS.usuario inner join VENTAS.tipo_usuario using(id_tipo_usuario)&quot;;</span>
      
<span class="nc" id="L580">        List&lt;Usuarios&gt; listaU = jdbcTemplate.query(sql,  BeanPropertyRowMapper.newInstance(Usuarios.class));</span>
<span class="nc" id="L581">        return listaU;</span>

    }

     /**
        * @deprecated
         * &lt;p&gt;Método utilizado para listar usuarios&lt;/p&gt;
         *@return una lista de tipo usuario 
         
    */ 
    public List&lt;Usuarios&gt; getUsuarioporNombre() {
        

<span class="nc" id="L594">        String sql = &quot;select *from VENTAS.usuario inner join VENTAS.tipo_usuario using(id_tipo_usuario) where nombre = ?&quot;;      </span>
<span class="nc" id="L595">        List&lt;Usuarios&gt; listaU = jdbcTemplate.query(sql,  BeanPropertyRowMapper.newInstance(Usuarios.class));</span>
<span class="nc" id="L596">        return listaU;</span>

    }

   

    /**
         * &lt;p&gt;Método para actualizar un usuario&lt;/p&gt;
         * @param nuevo objeto tipo usuario que manda las actualizaciones
         
    */ 
    public void updateU(Usuarios nuevo) {
<span class="nc" id="L608">        String sql = &quot;UPDATE VENTAS.usuario SET usuario=:usuario , id_tipo_usuario=:id_tipo_usuario WHERE id_usuario=:id_usuario&quot;;</span>
<span class="nc" id="L609">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(nuevo);</span>

<span class="nc" id="L611">        NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(jdbcTemplate);</span>
<span class="nc" id="L612">        template.update(sql, param);</span>

        

<span class="nc" id="L616">    }</span>

    /**
         * &lt;p&gt;Método para eliminar un usuario especifico&lt;/p&gt;
         * @param id es el identificador para eliminar el usuario en especifico 
         
    */ 
    public void deleteUsuario(int id) {
<span class="nc" id="L624">        String sql = &quot;DELETE FROM VENTAS.usuario WHERE id_usuario = ?&quot;;</span>
<span class="nc" id="L625">        jdbcTemplate.update(sql, id);</span>
<span class="nc" id="L626">    }</span>

     /**
         * &lt;p&gt;Método para crear usuarios dentro del sistema de ventas&lt;/p&gt;
         * @param  nuevo objeto de tipo usuario 
         *  @throws IOException
         
    */ 
    public void crearU(Usuarios nuevo) throws IOException {

  

<span class="nc" id="L638">        SimpleJdbcInsert insertActor = new SimpleJdbcInsert(jdbcTemplate);</span>
<span class="nc" id="L639">        insertActor.withSchemaName(&quot;VENTAS&quot;).withTableName(&quot;USUARIO&quot;).usingColumns( &quot;usuario&quot;,&quot;contraseña&quot;,&quot;id_tipo_usuario&quot;);</span>
<span class="nc" id="L640">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(nuevo);</span>
<span class="nc" id="L641">        insertActor.execute(param);</span>
<span class="nc" id="L642">     }</span>

 

  

 //TODO: Manejo del historial 

    /**
         * &lt;p&gt;Método para mostrar los cambios realizados&lt;/p&gt;
         * @return una lista con los cambios de tipo Historial 
         
         * 
    */ 
    public List&lt;Historial&gt; cambios() {
<span class="nc" id="L657">        String sql = &quot;select *from ventas.historial order by fecha_cambio desc&quot;;</span>
<span class="nc" id="L658">        List&lt;Historial&gt; listaDis = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Historial.class));</span>
<span class="nc" id="L659">        return listaDis;</span>

    }

     /**
         * &lt;p&gt;Método para eliminiar el historial, solo queda guardado cuando fue la ultima vez que se elimino&lt;/p&gt;
         * @throws IOException        
    */ 
    public void historialBorrar() throws IOException {
<span class="nc" id="L668">        String sql = &quot;delete from ventas.historial where cambio != 'Elimino historial'&quot;;</span>
<span class="nc" id="L669">        jdbcTemplate.update(sql);</span>
<span class="nc" id="L670">    }</span>

    /**
         * &lt;p&gt;Método insertar cambios al historial&lt;/p&gt;
         * @param  usuario quien realizo el cambio
         *  @param cambio que cambio realizo 
         * @param tabla en que se realizo el cambio
         * @throws IOException
    */ 
    public void historialC(String usuario,String cambio, String tabla) throws IOException {
<span class="nc" id="L680">        String sql = &quot;insert into ventas.historial(usuario,cambio,tabla,fecha_cambio) values(?,?,?, cast(current_date as timestamp) at time zone 'UTC')&quot;;</span>
<span class="nc" id="L681">        jdbcTemplate.update(sql, usuario,cambio,tabla);  </span>

<span class="nc" id="L683">      }</span>

    /**
         * &lt;p&gt;Método para mostrar dispositivos de una vista&lt;/p&gt;
         * @return una lista de tipo de telefono resultado de consultar una vista       
    */ 
    public List&lt;Telefono&gt; listTerminales() {
<span class="nc" id="L690">        String sql = &quot;select *from VENTAS.VIEW2&quot;;</span>
<span class="nc" id="L691">        List&lt;Telefono&gt; listaDis = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L692">        return listaDis;</span>

    }  

    /**
     * &lt;p&gt;Método para mostrar las compras individuales de cada cliente&lt;/p&gt;
     * @param id identificador del cliente a consultar    
    */ 
    public List&lt;Pedido&gt; mostrarC(int id) {
        

<span class="nc" id="L703">        String sql = &quot;select *from ventas.view1 where id_cliente = ? and compra =1 &quot;;</span>
<span class="nc" id="L704">        Object[] args = { id };</span>
<span class="nc" id="L705">        List&lt;Pedido&gt; listaF = jdbcTemplate.query(sql,args,  BeanPropertyRowMapper.newInstance(Pedido.class));</span>
<span class="nc" id="L706">        return listaF;</span>

    }

    /**
     * &lt;p&gt;Retornar una lista con información de los pedidos&lt;/p&gt;
     * @return listaF retorna una lista del tipo Pedido para más adelante gráficarlos
    
    */ 
    public List&lt;Pedido&gt; board() {        

<span class="nc" id="L717">        String sql = &quot;select nombref, sum(cantidad) as cantidad from ventas.view3  where compra =1  group by nombref  &quot;;        </span>
<span class="nc" id="L718">        List&lt;Pedido&gt; listaF = jdbcTemplate.query(sql,  BeanPropertyRowMapper.newInstance(Pedido.class));</span>
<span class="nc" id="L719">        return listaF;</span>

    }

    //TODO: Métodos para el manejo de las FABRICAs 
    /**
     * &lt;p&gt;Método para mostrar la info de todas las fabircas dentro de la bd&lt;/p&gt;
     * @return listaDis que es una lista con los datos de todas las FABRICAs
      
    */ 
    public List&lt;Fabrica&gt; listFabrica() {
<span class="nc" id="L730">        String sql = &quot;select *from VENTAS.FABRICA&quot;;</span>
<span class="nc" id="L731">        List&lt;Fabrica&gt; listaDis = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Fabrica.class));</span>
<span class="nc" id="L732">        return listaDis;</span>

    }

    /**
     * &lt;p&gt;Método para guardar los datos de una FABRICA&lt;/p&gt;
     * @param nuevo objeto de tipo FABRICA para guardar los datos de la fab en la bd
     * @throws IOException 
      
    */ 
    public void guardarFabrica(Fabrica nuevo) throws IOException {

  

<span class="nc" id="L746">        SimpleJdbcInsert insertActor = new SimpleJdbcInsert(jdbcTemplate);</span>
<span class="nc" id="L747">        insertActor.withSchemaName(&quot;VENTAS&quot;).withTableName(&quot;FABRICA&quot;).usingColumns(&quot;IP&quot;,&quot;PUERTO&quot;,&quot;NOMBREF&quot;);</span>
<span class="nc" id="L748">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(nuevo);</span>

<span class="nc" id="L750">        insertActor.execute(param);</span>



<span class="nc" id="L754">    }</span>

    /**
     * &lt;p&gt;Método para obtener información de una  FABRICA&lt;/p&gt;
     * @param id el identificador de la FABRICA para obtener sus datos 
     * @return listaIn que es una lista del tipo FABRICA, tiene los datos de la FABRICA en particular
     
    */ 
    public List&lt;Fabrica&gt; getFab(int id) {
<span class="nc" id="L763">        String sql = &quot;select *from VENTAS.FABRICA where id_FABRICA = ?&quot;;</span>
<span class="nc" id="L764">        Object[] args = { id };</span>
<span class="nc" id="L765">        List&lt;Fabrica&gt; listaIn = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Fabrica.class));</span>
<span class="nc" id="L766">        return listaIn;</span>

    }
     /**
     * &lt;p&gt;Método para obtener información de una  FABRICA&lt;/p&gt;
     * @param id el identificador de la FABRICA para obtener sus datos 
     * @return listaIn que es una lista del tipo FABRICA, tiene los datos de la FABRICA en particular
     
    */ 
    public List&lt;Fabrica&gt; getFabdaots(int id) {
<span class="nc" id="L776">        String sql = &quot;select *from ventas.FABRICA inner join ventas.BODEGA on id_FABRICA =origen where id_FABRICA =?&quot;;</span>
<span class="nc" id="L777">        Object[] args = { id };</span>
<span class="nc" id="L778">        List&lt;Fabrica&gt; listaIn = jdbcTemplate.query(sql, args, BeanPropertyRowMapper.newInstance(Fabrica.class));</span>
<span class="nc" id="L779">        return listaIn;</span>

    }


    /**
     * &lt;p&gt;Método para eliminar el acceso a una FABRICA&lt;/p&gt;
     * @param id el identificador de la FABRICA para eliminarlo
     
    */ 
    public void deletefab(int id) {
<span class="nc" id="L790">        String sql = &quot;DELETE FROM VENTAS.FABRICA WHERE id_FABRICA = ?&quot;;</span>
<span class="nc" id="L791">        jdbcTemplate.update(sql, id);</span>
<span class="nc" id="L792">    }</span>

    /**
     * &lt;p&gt;Método secundario para salvar telefonos que se reciben del rest&lt;/p&gt;
     * @param nuevo que es el objeto de telefono a guardar en la db
     * @throws IOException
     
    */ 
    public void save2(Telefono nuevo) throws IOException {

  

<span class="nc" id="L804">        SimpleJdbcInsert insertActor = new SimpleJdbcInsert(jdbcTemplate);</span>
<span class="nc" id="L805">        insertActor.withSchemaName(&quot;VENTAS&quot;).withTableName(&quot;BODEGA&quot;).usingColumns( &quot;existencia&quot;,</span>
                &quot;precio_lista&quot;, &quot;codigo_modelo&quot;, &quot;ram&quot;, &quot;almacenamiento&quot;, &quot;procesador&quot;, &quot;numero_cores&quot;, &quot;color&quot;,
                &quot;descripcion&quot;, &quot;nombret&quot;,&quot;origen&quot;,&quot;id_estados&quot;);
<span class="nc" id="L808">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(nuevo);</span>

<span class="nc" id="L810">        insertActor.execute(param);</span>
<span class="nc" id="L811">        }</span>


     /**
      * @deprecated
     * &lt;p&gt;Método para mostrar los pedidos realizados &lt;/p&gt;
     
    */ 
    public List&lt;Telefono&gt; listPedidoF() {
<span class="nc" id="L820">        String sql = &quot;select *from ventas.estadosf inner join(select *from VENTAS.BODEGA inner join VENTAS.FABRICA on origen = id_FABRICA where id_estados = 1)a on ID_ESTADOF = ID_ESTADOS&quot;;</span>
<span class="nc" id="L821">        List&lt;Telefono&gt; listaDis = jdbcTemplate.query(sql, BeanPropertyRowMapper.newInstance(Telefono.class));</span>
<span class="nc" id="L822">        return listaDis;</span>

    }

    /**
     * &lt;p&gt;Método para confirmar pedido, cambia el estado del pedido dentro de la bd para confirmarlo&lt;/p&gt;
     * @param n que es un objeto del tipo telefono que es la terminal que se confirma para el pedido 
     
    */ 
    public void confirmarP(Telefono n) {
<span class="nc" id="L832">        String sql = &quot;UPDATE VENTAS.BODEGA set id_estados=:id_estados where id_BODEGA=:id_BODEGA&quot;;</span>
<span class="nc" id="L833">        BeanPropertySqlParameterSource param = new BeanPropertySqlParameterSource(n);</span>

<span class="nc" id="L835">        NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(jdbcTemplate);</span>

<span class="nc" id="L837">        template.update(sql, param);</span>

<span class="nc" id="L839">    }</span>

    /**
     * &lt;p&gt;Método para generar un listado con las ventas realizadas&lt;/p&gt;
     * @return listaDis que es una lista con los telefonos vendidos
     
    */ 
    public List&lt;EnviarCorreo&gt; listaReporte(int origen) {
<span class="nc" id="L847">        String sql = &quot;select nombret, cantidadp, cantidadp_a, total_c,origen  from ventas.FABRICA inner join(select *from ventas.BODEGA inner join ventas.pedido using(id_BODEGA))a on origen = id_FABRICA where id_estado = 2 and origen = ?&quot;;</span>
<span class="nc" id="L848">        Object[] args = { origen };</span>
<span class="nc" id="L849">        List&lt;EnviarCorreo&gt; listaDis = jdbcTemplate.query(sql,args, BeanPropertyRowMapper.newInstance(EnviarCorreo.class));</span>
<span class="nc" id="L850">        return listaDis;</span>

    }

    public void asignarNum(int dueño,int times) {
<span class="nc" id="L855">        String sql = &quot;UPDATE VENTAS.numeros_serie set estadov=1,dueño=? where estadov= 0 and rownum &lt;=  &quot; + times+ &quot;&quot;;</span>
<span class="nc" id="L856">        jdbcTemplate.update(sql, dueño);</span>
<span class="nc" id="L857">    }</span>

    public void asignarNumPermanente(int dueño,int times) {
<span class="nc" id="L860">        String sql = &quot;UPDATE VENTAS.numeros_serie set estadov=1,dueño=?  rownum &lt;=  &quot; + times+ &quot;&quot;;</span>
<span class="nc" id="L861">        jdbcTemplate.update(sql, dueño);</span>
<span class="nc" id="L862">    }</span>
    
    
    
   


  


















}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>